//=============================================================================================
// Mintaprogram: Zöld háromszög. Ervenyes 2019. osztol.
//
// A beadott program csak ebben a fajlban lehet, a fajl 1 byte-os ASCII karaktereket tartalmazhat, BOM kihuzando.
// Tilos:
// - mast "beincludolni", illetve mas konyvtarat hasznalni
// - faljmuveleteket vegezni a printf-et kiveve
// - Mashonnan atvett programresszleteket forrasmegjeloles nelkul felhasznalni es
// - felesleges programsorokat a beadott programban hagyni!!!!!!! 
// - felesleges kommenteket a beadott programba irni a forrasmegjelolest kommentjeit kiveve
// ---------------------------------------------------------------------------------------------
// A feladatot ANSI C++ nyelvu forditoprogrammal ellenorizzuk, a Visual Studio-hoz kepesti elteresekrol
// es a leggyakoribb hibakrol (pl. ideiglenes objektumot nem lehet referencia tipusnak ertekul adni)
// a hazibeado portal ad egy osszefoglalot.
// ---------------------------------------------------------------------------------------------
// A feladatmegoldasokban csak olyan OpenGL fuggvenyek hasznalhatok, amelyek az oran a feladatkiadasig elhangzottak 
// A keretben nem szereplo GLUT fuggvenyek tiltottak.
//
// NYILATKOZAT
// ---------------------------------------------------------------------------------------------
// Nev    : 
// Neptun : 
// ---------------------------------------------------------------------------------------------
// ezennel kijelentem, hogy a feladatot magam keszitettem, es ha barmilyen segitseget igenybe vettem vagy
// mas szellemi termeket felhasznaltam, akkor a forrast es az atvett reszt kommentekben egyertelmuen jeloltem.
// A forrasmegjeloles kotelme vonatkozik az eloadas foliakat es a targy oktatoi, illetve a
// grafhazi doktor tanacsait kiveve barmilyen csatornan (szoban, irasban, Interneten, stb.) erkezo minden egyeb
// informaciora (keplet, program, algoritmus, stb.). Kijelentem, hogy a forrasmegjelolessel atvett reszeket is ertem,
// azok helyessegere matematikai bizonyitast tudok adni. Tisztaban vagyok azzal, hogy az atvett reszek nem szamitanak
// a sajat kontribucioba, igy a feladat elfogadasarol a tobbi resz mennyisege es minosege alapjan szuletik dontes.
// Tudomasul veszem, hogy a forrasmegjeloles kotelmenek megsertese eseten a hazifeladatra adhato pontokat
// negativ elojellel szamoljak el es ezzel parhuzamosan eljaras is indul velem szemben.
//=============================================================================================
//=============================================================================================
// Beltrami-Poincare disc model of hyperbolic geometry
//=============================================================================================


#include "framework.h"
const char* const VertexSourceHami = R"(
	#version 330
    precision highp float;

	
    uniform vec2 pozicio, fej;

	layout(location = 0) in vec2 vertexPosition;	// Attrib Array 0

	void main() {
		vec2 normal = vec2(-fej.y, fej.x);

		vec2 p = ((vertexPosition.x * fej) + (normal*vertexPosition.y)+ (pozicio));
		gl_Position = vec4(p.x, p.y, 0, 1);
	}
)";

const char* const vertexSource = R"(
		#version 330
		precision highp float;

		uniform mat4 MVP;			// Model-View-Projection matrix in row-major format

		layout(location = 0) in vec2 vertexPosition;	// Attrib Array 0

		void main() {
		gl_Position = vec4(vertexPosition.x, vertexPosition.y, 0, 1)* MVP;}	
	)";

const char* const fragmentSource = R"(
		#version 330
		precision highp float;
		uniform vec3 color;
		out vec4 fragmentColor;	

		void main() { fragmentColor = vec4(color, 1); }
	)";

GPUProgram gpuProgram;	// vertex and fragment shaders
unsigned int vao1, vbo1;
std::vector<vec2> pontok2;
std::vector<vec2> pontokzold;
vec2 rp1, rp2, gp1, gp2;

mat4 MVPTransform(1, 0, 0, 0,
	0, 1, 0, 0,
	0, 0, 1, 0,
	0, 0, 0, 1);


struct DualisSzam {
	//--------------------------
	float value, derivative;

	DualisSzam(float f0 = 0, float d0 = 0) { value = f0, derivative = d0; }
	DualisSzam operator-() { return DualisSzam(-value, -derivative); }
	float& f() { return value; }
	float& d() { return derivative; }
};

inline DualisSzam operator+(DualisSzam l, DualisSzam r) { return DualisSzam(l.f() + r.f(), l.d() + r.d()); }
inline DualisSzam operator-(DualisSzam l, DualisSzam r) { return DualisSzam(l.f() - r.f(), l.d() - r.d()); }
inline DualisSzam operator*(DualisSzam l, DualisSzam r) { return DualisSzam(l.f() * r.f(), l.f() * r.d() + l.d() * r.f()); }
inline DualisSzam operator/(DualisSzam l, DualisSzam r) { return DualisSzam(l.f() / r.f(), (l.d() * r.f() - l.f() * r.d()) / r.f() / r.f()); }

// Elementary functions prepared for the chain rule as well
inline DualisSzam Sin(DualisSzam g) { return DualisSzam(sin(g.f()), cos(g.f()) * g.d()); }
inline DualisSzam Cos(DualisSzam g) { return DualisSzam(cos(g.f()), -sin(g.f()) * g.d()); }

inline DualisSzam Pow(DualisSzam g, float n) { return DualisSzam(powf(g.f(), n), n * powf(g.f(), n - 1) * g.d()); }

inline DualisSzam SinHip(DualisSzam g) {
	return DualisSzam(sinhf(g.f()), coshf(g.d()));
}
inline DualisSzam CosHip(DualisSzam g) {
	return DualisSzam(coshf(g.f()), sinhf(g.d()));
}


int forditott(int t) {
	if (t > 80)
		return 80 - (t - 80);
	return t;
}

class Hami {
	unsigned int vao;	// vertex array object id
	float phi;			// angle of rotation
	float csukasNyitas;
	vec3 color;
	vec2 nezeseltolas;

public:
	Hami() {
		Animate(0);
		csukasNyitas = 30;
		nezeseltolas = vec2(0.009f, 0.009f);

	}

	void create(vec3 colour) {
		color = colour;
		glGenVertexArrays(1, &vao);	// create 1 vertex array object
		glBindVertexArray(vao);		// make it active

		unsigned int vbo;		// vertex buffer objects
		glGenBuffers(1, &vbo);	// Generate 2 vertex buffer objects
		glBindBuffer(GL_ARRAY_BUFFER, vbo); // make it active, it is an array


	}

	void testElokeszit() {
		//nv=100
		vec2 foKor[100];
		for (int i = 0; i < 100; i++) {
			float fi = i * 2 * M_PI / 100;
			foKor[i] = vec2(cos(fi) / 10, sin(fi) / 10);
		}


		glBufferData(GL_ARRAY_BUFFER,      // copy to the GPU
			sizeof(vec2) * 100, // number of the vbo in bytes
			foKor,		   // address of the data array on the CPU
			GL_STATIC_DRAW);	   // copy to that part of the memory which is not modified 
		// Map Attribute Array 0 to the current bound vertex buffer (vbo[0])
		glEnableVertexAttribArray(0);
		// Data organization of Attribute Array 0 
		glVertexAttribPointer(0,			// Attribute Array 0
			2, GL_FLOAT,  // components/attribute, component type
			GL_FALSE,		// not in fixed point format, do not normalized
			0, NULL);     // stride and offset: it is tightly packed
		gpuProgram.setUniform(color, "color");
	}
	void szem1Elokeszit() {
		//nv=100
		vec2 szemek[100];
		for (int i = 0; i < 100; i++) {
			float fi = i * 2 * M_PI / 100;
			szemek[i] = vec2(cos(fi) / 50 + 0.08, sin(fi) / 50 - 0.06);
		}


		glBufferData(GL_ARRAY_BUFFER,      // copy to the GPU
			sizeof(vec2) * 100, // number of the vbo in bytes
			szemek,		   // address of the data array on the CPU
			GL_STATIC_DRAW);	   // copy to that part of the memory which is not modified 
		// Map Attribute Array 0 to the current bound vertex buffer (vbo[0])
		glEnableVertexAttribArray(0);
		// Data organization of Attribute Array 0 
		glVertexAttribPointer(0,			// Attribute Array 0
			2, GL_FLOAT,  // components/attribute, component type
			GL_FALSE,		// not in fixed point format, do not normalized
			0, NULL);     // stride and offset: it is tightly packed
		gpuProgram.setUniform(vec3(1.0f, 1.0f, 1.0f), "color");
	}
	void szajElokeszit() {

		vec2 szaj[100];
		for (int i = 0; i < 100; i++) {
			float fi = i * 2 * M_PI / 100;
			szaj[i] = vec2(cos(fi) / (16 + forditott(csukasNyitas)) + 0.11, sin(fi) / (16 + forditott(csukasNyitas)));
		}


		glBufferData(GL_ARRAY_BUFFER,      // copy to the GPU
			sizeof(vec2) * 100, // number of the vbo in bytes
			szaj,		   // address of the data array on the CPU
			GL_STATIC_DRAW);	   // copy to that part of the memory which is not modified 
		// Map Attribute Array 0 to the current bound vertex buffer (vbo[0])
		glEnableVertexAttribArray(0);
		// Data organization of Attribute Array 0 
		glVertexAttribPointer(0,			// Attribute Array 0
			2, GL_FLOAT,  // components/attribute, component type
			GL_FALSE,		// not in fixed point format, do not normalized
			0, NULL);     // stride and offset: it is tightly packed

		gpuProgram.setUniform(vec3(0.0f, 0.0f, 0.0f), "color");
	}
	void szem2Elokeszit() {
		//nv=100
		vec2 szemek[100];
		for (int i = 0; i < 100; i++) {
			float fi = i * 2 * M_PI / 100;
			szemek[i] = vec2(cos(fi) / 50 + 0.08, sin(fi) / 50 + 0.06);
		}


		glBufferData(GL_ARRAY_BUFFER,      // copy to the GPU
			sizeof(vec2) * 100, // number of the vbo in bytes
			szemek,		   // address of the data array on the CPU
			GL_STATIC_DRAW);	   // copy to that part of the memory which is not modified 
		// Map Attribute Array 0 to the current bound vertex buffer (vbo[0])
		glEnableVertexAttribArray(0);
		// Data organization of Attribute Array 0 
		glVertexAttribPointer(0,			// Attribute Array 0
			2, GL_FLOAT,  // components/attribute, component type
			GL_FALSE,		// not in fixed point format, do not normalized
			0, NULL);     // stride and offset: it is tightly packed
		gpuProgram.setUniform(vec3(1.0f, 1.0f, 1.0f), "color");
	}

	void szemgolyo2() {
		//nv=100
		vec2 szemek[100];
		for (int i = 0; i < 100; i++) {
			float fi = i * 2 * M_PI / 100;
			szemek[i] = vec2(cos(fi) / 90 + 0.08 + nezeseltolas.x, sin(fi) / 90 + 0.06 + nezeseltolas.y);
		}


		glBufferData(GL_ARRAY_BUFFER,      // copy to the GPU
			sizeof(vec2) * 100, // number of the vbo in bytes
			szemek,		   // address of the data array on the CPU
			GL_STATIC_DRAW);	   // copy to that part of the memory which is not modified 
		// Map Attribute Array 0 to the current bound vertex buffer (vbo[0])
		glEnableVertexAttribArray(0);
		// Data organization of Attribute Array 0 
		glVertexAttribPointer(0,			// Attribute Array 0
			2, GL_FLOAT,  // components/attribute, component type
			GL_FALSE,		// not in fixed point format, do not normalized
			0, NULL);     // stride and offset: it is tightly packed
		gpuProgram.setUniform(vec3(0.0f, 0.0f, 1.0f), "color");
	}

	void szemgolyo1() {
		//nv=100
		vec2 szemek[100];
		for (int i = 0; i < 100; i++) {
			float fi = i * 2 * M_PI / 100;
			szemek[i] = vec2(cos(fi) / 90 + 0.08 + nezeseltolas.x, sin(fi) / 90 - 0.06 + nezeseltolas.y);
		}


		glBufferData(GL_ARRAY_BUFFER,      // copy to the GPU
			sizeof(vec2) * 100, // number of the vbo in bytes
			szemek,		   // address of the data array on the CPU
			GL_STATIC_DRAW);	   // copy to that part of the memory which is not modified 
		// Map Attribute Array 0 to the current bound vertex buffer (vbo[0])
		glEnableVertexAttribArray(0);
		// Data organization of Attribute Array 0 
		glVertexAttribPointer(0,			// Attribute Array 0
			2, GL_FLOAT,  // components/attribute, component type
			GL_FALSE,		// not in fixed point format, do not normalized
			0, NULL);     // stride and offset: it is tightly packed
		gpuProgram.setUniform(vec3(0.0f, 0.0f, 1.0f), "color");
	}

	void Animate(float t) {

		phi = phi + t;
	}
	void setCsukasNyitas(float t) {
		csukasNyitas = t;
	}

	mat4 M() {
		mat4 Mrotate(cosf(phi), sinf(phi), 0, 0,
			-sinf(phi), cosf(phi), 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1); // rotation

		return Mrotate;	// model transformation
	}

	void Draw(vec2 pozicio, vec2 fejIrany) {
		//gpuProgram.setUniform(MVPTransform * M(), "MVP");
		gpuProgram.setUniform(pozicio, "pozicio");
		gpuProgram.setUniform(fejIrany, "fej");
		//a colort az eklokeszitok allitjak be!!!


		glBindVertexArray(vao);	// make the vao and its vbos active playing the role of the data source
		testElokeszit();
		glDrawArrays(GL_TRIANGLE_FAN, 0, 100);	// draw a single triangle with vertices defined in vao

		szajElokeszit();
		glDrawArrays(GL_TRIANGLE_FAN, 0, 100);	// draw a single triangle with vertices defined in vao

		szem1Elokeszit();
		glDrawArrays(GL_TRIANGLE_FAN, 0, 100);	// draw a single triangle with vertices defined in vao

		szem2Elokeszit();
		glDrawArrays(GL_TRIANGLE_FAN, 0, 100);	// draw a single triangle with vertices defined in vao

		szemgolyo1();
		glDrawArrays(GL_TRIANGLE_FAN, 0, 100);	// draw a single triangle with vertices defined in vao

		szemgolyo2();
		glDrawArrays(GL_TRIANGLE_FAN, 0, 100);	// draw a single triangle with vertices defined in vao


	}

	void setNezesEltolas(vec2 irany) {
		nezeseltolas = vec2(irany.y, -irany.x);
		//printf("eltolas erteke: %f,%f\n",nezeseltolas.x,nezeseltolas.y);
	}
};

// Path of the object and the derivative with Clifford algebra
void greenPath(float tt, DualisSzam& x, DualisSzam& y) {
	DualisSzam t(tt, 1);
	x = 0.5f + 0.2f * Cos(t);
	y = 0 + 0.2f * Sin(t);
	pontokzold.push_back(vec2(x.f(), y.f()));
}

float iranyX = 0.5;
float iranyY = 1.5;
float pozicioX = -0.7f;
float offsetY = -0.5f;
float sum = 0;
DualisSzam rx, ry;

void pirosPalya(float tt, DualisSzam& x, DualisSzam& y) {
	DualisSzam t(tt, 1);

	x = pozicioX * CosHip(t) + 0.6f * iranyX * SinHip(t);
	y = offsetY * CosHip(t) + 0.6f * iranyY * SinHip(t);
	pontok2.push_back(vec2(x.f(), y.f()));
}

vec2 meroleges(float tt, DualisSzam x, DualisSzam y) {
	DualisSzam t(tt, 1);

	x = -0.1f * CosHip(t) + 1 * SinHip(t);
	y = -0.8f * CosHip(t) + 2 * SinHip(t);

	return vec2(y.d(), -x.d());


}




// The virtual world
std::vector<vec2> circlePoints;

vec2 normalIrany;

void csikpiros() {

	//bind
	glBindVertexArray(vao1);
	//bind
	glBindBuffer(GL_ARRAY_BUFFER, vbo1);
	glBufferData(GL_ARRAY_BUFFER, pontok2.size() * sizeof(vec2), &pontok2[0], GL_DYNAMIC_DRAW);
	glEnableVertexAttribArray(0);  // attribute array 0
	glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), NULL);


	gpuProgram.setUniform(vec3(1.0f, 1.0f, 1.0f), "color");
	glDrawArrays(GL_POINTS, 0, pontok2.size());
}

void csikzold() {

	//bind
	glBindVertexArray(vao1);
	//bind
	glBindBuffer(GL_ARRAY_BUFFER, vbo1);
	glBufferData(GL_ARRAY_BUFFER, pontokzold.size() * sizeof(vec2), &pontokzold[0], GL_DYNAMIC_DRAW);
	glEnableVertexAttribArray(0);  // attribute array 0
	glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), NULL);


	gpuProgram.setUniform(vec3(1.0f, 1.0f, 1.0f), "color");
	glDrawArrays(GL_POINTS, 0, pontokzold.size());
}


void szembenez() {

	vec2 iranyvektor = vec2(rp1.x - gp1.x, rp1.y - gp1.y);
	float locallenght = sqrt(pow(iranyvektor.x, 2.0f) + pow(iranyvektor.y, 2.0f)) * 100;
	normalIrany = vec2(iranyvektor.x / locallenght, iranyvektor.y / locallenght);
}

//HAMIK
Hami hami1;
Hami hami2;
bool mehet = false;



// Initialization, create an OpenGL context
//nagy kor
void onInitialization() {
	gpuProgram.create(vertexSource, fragmentSource, "outColor");

	hami1.create(vec3(0.0f, 1.0f, 0.0f));
	hami2.create(vec3(1.0f, 0.0f, 0.0f));

	//nagy DISK
	for (int i = 0; i < 60; i++) {
		float phi = i * 2.0f * M_PI / 60;
		circlePoints.push_back(vec2(cosf(phi), sinf(phi)));
	}


	glViewport(0, 0, windowWidth, windowHeight);
	glLineWidth(2.0f);
	glPointSize(2.0f);

	//innen atszervezheto egy object-be!!!
	glGenVertexArrays(1, &vao1);
	//bind
	glBindVertexArray(vao1);
	glGenBuffers(1, &vbo1);
	//bind
	glBindBuffer(GL_ARRAY_BUFFER, vbo1);
	glEnableVertexAttribArray(0);  // attribute array 0
	glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), NULL);


}


void onDisplay() {
	gpuProgram.create(vertexSource, fragmentSource, "fragmentColor");
	glClearColor(0.35, 0.35, 0.35, 0.35);							// background color 
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the screen

	gpuProgram.setUniform(MVPTransform, "MVP");

	//DISK kiirasa
	glBindVertexArray(vao1);
	glBindBuffer(GL_ARRAY_BUFFER, vbo1);
	glBufferData(GL_ARRAY_BUFFER, circlePoints.size() * sizeof(vec2), &circlePoints[0], GL_DYNAMIC_DRAW);
	gpuProgram.setUniform(vec3(0.0f, 0.0f, 0.0f), "color");
	glDrawArrays(GL_TRIANGLE_FAN, 0, circlePoints.size());

	//csik kiirasa
	csikpiros();
	csikzold();


	//UUJJ VERTEXSHADER
	gpuProgram.create(VertexSourceHami, fragmentSource, "fragmentColor");
	long time = glutGet(GLUT_ELAPSED_TIME); // elapsed time since the start of the program

	float idoPiros;
	float idoZold;
	if (mehet) {
		idoPiros = time / 1000.0f - sum;

	}
	idoZold = time / 1000.0f;

	//Zold HAMI
	DualisSzam gx, gy;
	greenPath(idoZold / 8, gx, gy);
	vec2 gposition(gx.value, gy.value);
	gp1 = vec2(gx.value + 0.08, gy.value + 0.06);
	gp2 = vec2(gx.value + 0.08, gy.value - 0.06);
	vec2 gvelocity(gx.derivative, gy.derivative);
	float gspeed = length(gvelocity);
	vec2 gheading = gvelocity / gspeed;
	szembenez();
	hami1.setNezesEltolas(normalIrany);

	hami1.Draw(gposition, gheading);

	//Piros HAMI

	pirosPalya(idoPiros / 8, rx, ry);
	vec2 rposition(rx.value, ry.value);
	rp1 = vec2(rx.value + 0.08, ry.value + 0.06);
	rp2 = vec2(rx.value + 0.08, ry.value - 0.06);
	vec2 rvelocity(rx.derivative, ry.derivative);
	float rspeed = length(rvelocity);
	vec2 rheading = rvelocity / rspeed;

	szembenez();
	hami2.setNezesEltolas(vec2(-normalIrany.x, -normalIrany.y));
	hami2.Draw(rposition, rheading);

	glutSwapBuffers();
}















void onMouse(int button, int state, int pX, int pY) {

	glutPostRedisplay();

}


void onKeyboard(unsigned char key, int pX, int pY) {
	float temp;
	long time = glutGet(GLUT_ELAPSED_TIME);

	switch (key) {
	case 'f':
		sum = time / 1000.0f;
		temp = iranyX;
		iranyX = -iranyY;
		iranyY = temp;
		pozicioX = rx.f();
		offsetY = ry.f();



		//hami1.Animate(1.565);  
		break;
	case 's':
		sum = time / 1000.0f;
		temp = iranyX;
		iranyX = iranyY;
		iranyY = -temp;
		pozicioX = rx.f();
		offsetY = ry.f();
		break;
	case 'e':
		sum = time / 1000.0f;
		mehet = !mehet;
		pozicioX = rx.f();
		offsetY = ry.f();

		break;
	default: break;
	}
	glutPostRedisplay();
}


void onKeyboardUp(unsigned char key, int pX, int pY) {}

void onMouseMotion(int pX, int pY) { }

void onIdle() {
	long time = glutGet(GLUT_ELAPSED_TIME);
	float tt = time / 17.0f;
	int t = tt;
	hami1.setCsukasNyitas(t % 160);
	hami2.setCsukasNyitas(t % 160);

	glutPostRedisplay();
}